<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<html>

<head>
  <title>Instruction Tree</title>
  <style>@import url(style.css);</style>
</head>

<body class="jdocu_main">
<script type="text/javascript">
parent.frames['toc'].d.openTo(25, true);
</script>
<a name="label60"></a><p class="jdocu_navbarp"><span class="jdocu_navbar"><a class="jdocu" href="topic5.html">Previous</a> - <a class="jdocu" href="topic4.html">Up</a> - <a class="jdocu" href="topic7.html">Next</a></span></p>
<h3 class="jdocu">3.2&nbsp;&nbsp;&nbsp;Instruction Tree</h3 class="jdocu">


<p>
<a name="label61"></a>
Simics builds a tree of active instructions to keep track of
dependence information. As instructions enter the <a name="label62">out-of-order
window</a>, they are added as leaves to the tree with the previous
instruction in program order as their parent. Instructions can only be
committed from the window when they are at the root of the
tree. Branches occur at <a name="label63">speculation points</a>. Currently two forms of
speculation are supported, control speculation and data speculation.
<p>
Control speculation <a name="label64"></a> <a name="label65"></a>occurs when the user model generates a fetch address
that has not yet been produced by an earlier <a name="label66">correct
instruction</a><a name="label67"></a>. The instruction being
fetched will be regarded as speculative but not necessarily incorrect
<a name="label68"></a><a name="label69"></a>. As
soon as the previous instruction executes non-speculatively the
address will be compared against the speculative address. If there is
a match the instruction will be considered correct and no longer
speculative.
<p>
Data speculation <a name="label70"></a><a name="label71"></a>occurs when the user supplies an input value to an
instruction that has not yet been generated by an earlier correct
instruction. As with fetches the instruction will be speculative until
the correct value arrives. If the value does not match, the
instruction becomes incorrect and need to be rewinded and re-executed
or squashed.
<p>
If the control or data speculation generates an address or value that
has already been produced by an earlier correct instruction the
comparison occurs immediately. Again, for matches the instruction will
be correct and for mismatches the instruction will be speculative.
<p>
To keep track of speculation, Simics labels each instruction as
speculative <a name="label72"></a>or correct. Speculative
does not imply incorrect, unless a correct branch exists. This
structure allows multiple speculative instruction paths to be
active. In the general case, to know if an instruction is correct or
incorrect, all previous instructions need to be executed and
non-speculative.
<p>
While Simics and the underlying MAI support an unlimited number of
speculative execution paths<a name="label73"></a>, the current
way it is used can add restrictions. The MAI is limited only by the
aggressiveness of the user model. The model can inspect the state
of a branch, deciding when incorrect instruction should be squashed.
<p>
The maximum size of the instruction tree is set by an attribute called
<i>reorder_buffer_size</i> in each CPU.
<p>
<a name="label74"></a><h4 class="jdocu">3.2.1&nbsp;&nbsp;&nbsp;Tracking Instruction Execution</h4 class="jdocu">


<p>
To keep track of the execution, each instruction can be queried on its
current phase, its current status and a flag indicating whether the
instruction is speculative or not. The phase describes where the
instruction is in an idealized pipeline. While this might suggest an
enormous number of possible states for each instruction, not all
combinations are legal or meaningful.
<p>
The six phases of an instruction are:
<p>
<dl><dt><b>Init</b></dt><dd><a name="label75"></a><a name="label76"></a>A place for the
instruction has been reserved in the out-of-order window. At this
point, it is possible to speculatively set the fetch address.</dd><dt><b>Fetch</b></dt><dd><a name="label77"></a><a name="label78"></a>The
instruction has been fetched from memory. If Simics was configured to
do so, an instruction fetch transaction has been sent to the memory
hierarchy and it has finished stalling. The instruction opcode is
available.</dd><dt><b>Decode</b></dt><dd><a name="label79"></a><a name="label80"></a>The
instruction has been decoded: its type and its input and output
registers are known. It is possible to query and set the values of the
input registers. If not all the input values are known the instruction
cannot be executed. No memory transaction is performed during this
phase so it can not stall.</dd><dt><b>Execute</b></dt><dd><a name="label81"></a><a name="label82"></a>The instruction has been executed: all output values have
been produced. Loads have been completed; stores have been issued and
are waiting in the <a name="label83">LSQ</a>. The instruction may still be speculative.</dd><dt><b>Retire</b></dt><dd><a name="label84"></a><a name="label85"></a>To
enter this phase, the instruction has to be non-speculative. Stores
are sent to memory from the <a name="label86">LSQ</a>.</dd><dt><b>Commit</b></dt><dd><a name="label87"></a><a name="label88"></a>To
enter this phase, an instruction must be root of the tree. The
instruction results are committed to the architectural register
state.</dd></dl>
<p>
An instruction is considered non-speculative when all the input values have
been validated against the previous non-speculative instructions that produced
them. The fetch address (PC) is included in the input values (control
speculation).
<p>
The <b>Retire</b> and <b>Commit</b> phases could be considered as part
of a <a name="label89">global commit phase</a>. The reason they are separated is
to allow users to retire stores out-of-order. Simics requires however
that commit to the <a name="label90">architectural state</a> be done in-order (when
instructions are root of the tree).
<p>
The status of an instruction is one of:
<p>
<dl><dt><b>Waiting</b></dt><dd><a name="label91"></a><a name="label92"></a>Some
input is missing and no speculation is done.</dd><dt><b>Ready</b></dt><dd><a name="label93"></a><a name="label94"></a>All needed
input have been produced or speculated.</dd><dt><b>Stalling</b></dt><dd><a name="label95"></a><a name="label96"></a>Executing a memory
transaction. This can happen during the Fetch, Execute and Retire
phases.</dd><dt><b>Faulting</b></dt><dd><a name="label97"></a><a name="label98"></a>The instruction has triggered an exception.</dd><dt><b>Trap (<i>x86 only</i>)</b></dt><dd><a name="label99"></a><a name="label100"></a>The instruction has triggered a trap.</dd><dt><b>Interrupt (<i>x86 only</i>)</b></dt><dd><a name="label101"></a><a name="label102"></a>An
immediate interrupt must be taken before executing this
instruction.</dd></dl>
<p>
<a name="label103"></a><h4 class="jdocu">3.2.2&nbsp;&nbsp;&nbsp;Instruction Tree Example</h4 class="jdocu">


<p>
Here follows an example of an instruction tree using SPARC assembly:
<p>
<pre class="jdocu_small" style="color: black">
  0 &lt;0xf000e7b8&gt; stx %g4, [%o2 + -16]           R 
  1 &lt;0xf000e7bc&gt; cmp %g4, 0                     R
  2 &lt;0xf000e7c0&gt; bne,pt %xcc, 0xf000e7ac        E
      3 &lt;0xf000e7c4&gt; add %o2, 16, %o2               E
      4 &lt;0xf000e7ac&gt; ldx [%o2 + 8], %g4             D (stalling)
      5 &lt;0xf000e7b0&gt; stx %g4, [%o2 + -8]            D (waiting for %g4) S
      6 &lt;0xf000e7b4&gt; ldx [%o2 + 0], %g4             D (stalling) 
      7 &lt;0xf000e7b8&gt; stx %g4, [%o2 + -16]           D (waiting for %g4) S
      8 &lt;0xf000e7bc&gt; cmp %g4, 0                     D (waiting for %g4) S
      9 &lt;0xf000e7c0&gt; bne,pt %xcc, 0xf000e7ac        D (waiting for %cc) S
  3 &lt;0xf000e7c4&gt; add %o2, 16, %o2               E S
  4 &lt;0xf000e7c8&gt; ld [%i4 + 0], %g4              D (stalling)
  5 &lt;0xf000e7cc&gt; add %g4, 1, %g4                D (waiting for %g4) S
  6 &lt;0xf000e7d0&gt; st %g4, [%i4 + 0]              D (waiting for %g4) S
  7 &lt;0xf000e7d4&gt; jmpl [%i7 + 8], %g0            E S
      8 &lt;0xf000e7d8&gt; restore %g0, %g0, %g0          E S
      9 &lt;0xf0009c18&gt; sethi %hi(0x4000), %i2         E S
     10 &lt;0xf0009c1c&gt; bne 0xf00096a8                 E S
         11 &lt;0xf0009c20&gt; nop                            E S
         12 &lt;0xf00096a8&gt; mov %i2, %o0                   E S
     11 &lt;0xf0009c20&gt; mov %i2, %o0                   E S
     12 &lt;0xf0009c24&gt; srl %o0, 0, %l0                E S
     13 &lt;0xf0009c28&gt; sethi %hi(0xf04b2400), %o0     E S
     14 &lt;0xf0009c2c&gt; add %o0, 896, %i0              E S
     15 &lt;0xf0009c30&gt; srl %i3, 0, %o1                E S
     16 &lt;0xf0009c34&gt; mov %i0, %o0                   E S
  8 &lt;0xf000e7d8&gt; restore %g0, %g0, %g0          E S
  9 &lt;0xf000e7dc&gt; bcs,a,pt %xcc, 0xf000e814      E S
 10 &lt;0xf000e7e4&gt; ldx [%o2 + 0], %o0             D (ready) S
 11 &lt;0xf000e7e8&gt; cmp %o0, 0                     F
 12 &lt;0xf000e7ec&gt; be,a,pt %xcc, 0xf000e814       F
 13 &lt;0xf000e7f0&gt; ld [%i4 + 0], %g4              F
</pre>
<p>
The tree shows instructions in several different phases. Instructions
2, 7, and 10 are branch instructions that each have 2 predicted
targets (jump target and fall through). This has created 4 possible
paths through the tree. F stands for Fetched, D for Decoded, E for
Executed, and R for retired. Committed instructions have been removed
from the tree. S means that the instruction is marked as
speculative.
<p>

<p class="jdocu_navbarp"><span class="jdocu_navbar"><a class="jdocu" href="topic5.html">Previous</a> - <a class="jdocu" href="topic4.html">Up</a> - <a class="jdocu" href="topic7.html">Next</a></span></p>
</body>
</html>
